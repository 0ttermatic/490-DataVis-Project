<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Death Locations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../javascript/functions.js"></script> 
    <style>
        body {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1c1c1c;
            padding-left: 300px;
        }
        svg {
            border: 1px solid #ccc;
        }
        .death-marker {
            stroke: black;
            stroke-width: 1;
            font-size: 14px;
            font-weight: bold;
        }

        #controls {
        position: absolute;
        top: 90px;
        left: 90px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #000;
        }

        #adc-checkbox {
            margin-top: 35px; 
        }
    </style>
</head>   
<body>
    <!-- Checkboxes-->
    <div id="controls">
        <label><input type="checkbox" id="all-supports" checked> SUPPORT</label>
        <label><input type="checkbox" id="enchanter-warden-checkbox" checked> Enchanter/Warden</label>
        <label><input type="checkbox" id="catcher-vanguard-checkbox" checked> Catcher/Vanguard</label>
        <label><input type="checkbox" id="adc-checkbox" checked> ADC</label>
        <label><input type="checkbox" id="attack-damage-carry" checked> attack-damage</label>
    </div>
    <script>
        let svg; 
        let scaledLocations = []; 
        
        let quad0 = 0
        let quad1 = 1
        let quad2 = 2
        let quad3 = 3
        let quad4 = 4
        let quad5 = 5
        let quad6 = 6

        // Path to the .json file
        const PathToFile = "../Data_Gathering/match_data_FINAL.json"; 
    
        // Map Width and Height
        const MapHeight = 810;
        const MapWidth = 810;
        const GridSize = 30; // Grid size 
        const numCols = MapWidth / GridSize; // Number of columns in the grid
        const numRows = MapHeight / GridSize; // Number of rows in the grid
    
        // Color scale for the heatmap
        let colorScale = d3.scaleLinear()
            .domain([quad0, quad1, quad2, quad3, quad4, quad5, quad6]) // Domain 
            .range(["rgba(255, 255, 255, 0)", "rgba(255, 244, 0, 1)", "rgba(255, 210, 0, 1)", "rgba(255, 150, 0, 1)", "rgba(255, 130, 0, 1)", "rgba(255, 75, 0, 1)", "rgba(255, 0, 0, 1)"]); // RGBA with capacity
    
        // Load and process the data
        JsonToVariable(PathToFile).then(data => {
    
            // Extract death locations and the side from the data
            const deathLocationsWithSide = data.map(entry => {
                return entry.deathLocations.map(loc => ({
                    x: loc.x, // Attach x coordinate
                    y: loc.y, // Attach y coordinate
                    side: entry.side, // Attach side value 
                    championName: entry.championName // Attach champion name
                }));
            }).flat();
    
            // Scale the coordinates 
            const scaleCoordinates = (loc) => {
                const xScaled = (loc.x / 15000) * MapWidth;
                const yScaled = MapHeight - (loc.y / 15000) * MapHeight;
                const row = Math.floor(yScaled / GridSize);
                const col = Math.floor(xScaled / GridSize);
                return {
                    x: xScaled,
                    y: yScaled,
                    side: loc.side,
                    championName: loc.championName,
                    row: row,
                    col: col
                };
            };
    
            scaledLocations = deathLocationsWithSide.map(scaleCoordinates);
            console.log("Scaled Locations:", scaledLocations);
    
            const deathCounts = Array.from({ length: numRows }, () => Array(numCols).fill(0));
            // Number of deaths in each grid cell
            scaledLocations.forEach(loc => {
                const row = Math.floor(loc.y / GridSize);
                const col = Math.floor(loc.x / GridSize);
                deathCounts[row][col]++;
            });
    
            // Create SVG container 
            if (!svg) {
                svg = d3.select("body")
                    .append("svg")
                    .attr("width", MapWidth)
                    .attr("height", MapHeight);
    
                svg.append("image")
                    .attr("href", "Summoner's_Rift_Minimap.png")
                    .attr("width", MapWidth)
                    .attr("height", MapHeight);
            }
    
            // Plot the grid cells (heatmap)
            svg.selectAll(".grid-cell")
                .data(d3.range(numRows * numCols))
                .enter()
                .append("rect")
                .attr("class", "grid-cell")
                .attr("x", d => (d % numCols) * GridSize)
                .attr("y", d => Math.floor(d / numCols) * GridSize)
                .attr("width", GridSize)
                .attr("height", GridSize)
                .style("fill", d => {
                    const row = Math.floor(d / numCols);
                    const col = d % numCols;
                    const deathCount = deathCounts[row][col];
                    return colorScale(deathCount); // Set color based on the death count
                })
                .style("stroke", "none")
                .style("filter", "blur(14px)"); // Apply blur effect
    
            // Log unmapped champions
            const unmappedChampions = scaledLocations.filter(d => !ChampionRoles[d.championName]);
            console.log("Unmapped Champions:", unmappedChampions);
    

            ///////////////// LOGIC FOR CHECKBOXES ON THE LEFT HAND SIDE ///////////////////////////
            // Attach event listeners to checkboxes (SUPPORTS)
            document.getElementById("all-supports").addEventListener("change", (event) => {
                const isChecked = event.target.checked;

                // Set all support boxes to be active
                document.getElementById("enchanter-warden-checkbox").checked = isChecked;
                document.getElementById("catcher-vanguard-checkbox").checked = isChecked;

                // Update the heatmap 
                updateHeatmapBasedOnCheckboxes();
            });

            // Function to update the state of "all-supports" based on the other checkboxes
            //checks if all support boxes are checked, and if not, will uncheck the SUPPORT box
            const updateAllSupportsState = () => {
                const enchanterChecked = document.getElementById("enchanter-warden-checkbox").checked;
                const catcherChecked = document.getElementById("catcher-vanguard-checkbox").checked;

                // "all-supports" is checked only if all support boxes are checked
                document.getElementById("all-supports").checked = enchanterChecked && catcherChecked;

                // Update the heatmap
                updateHeatmapBasedOnCheckboxes();
            };

            // Attach event listeners to all support boxes
            document.getElementById("enchanter-warden-checkbox").addEventListener("change", updateAllSupportsState);
            document.getElementById("catcher-vanguard-checkbox").addEventListener("change", updateAllSupportsState);







            // Attach event listeners to checkboxes (ADC's)
            document.getElementById("adc-checkbox").addEventListener("change", (event) => {
                const isChecked = event.target.checked;

                // Set all ADC boxes to be active
                document.getElementById("attack-damage-carry").checked = isChecked;

                // Update the heatmap 
                updateHeatmapBasedOnCheckboxes();

            // Function to update the state of "all-adc" based on the other checkboxes
            //checks if all adc boxes are checked, and if not, will uncheck the ADC box
            const updateAllADCState = () => {
                const attackDamageChecked = document.getElementById("attack-damage-carry").checked;

                // "all-ADC" is checked only if all adc boxes are checked
                document.getElementById("adc-checkbox").checked = attackDamageChecked;

                // Update the heatmap
                updateHeatmapBasedOnCheckboxes();
            };

            document.getElementById("attack-damage-carry").addEventListener("change", updateAllADCState);



            });
            document.getElementById("attack-damage-carry").addEventListener("change", updateHeatmapBasedOnCheckboxes);
            ////------------------------------------------------------------------------------/////






            // Initial render of the heatmap with all categories
            updateHeatmapBasedOnCheckboxes(); 
        }).catch(error => console.error("Error loading or processing data:", error));
    

        function updateHeatmapBasedOnCheckboxes() {
            // Get selected categories based on current checkboxes
            const selectedCategories = [];

            // If SUPPORT box is checked, check all support boxes
            if (document.getElementById("all-supports").checked) 
            {
                selectedCategories.push("Enchanter/Warden", "Catcher/Vanguard");
            } 
            // Else continue normally
            else 
            {
                if (document.getElementById("enchanter-warden-checkbox").checked) selectedCategories.push("Enchanter/Warden");
                if (document.getElementById("catcher-vanguard-checkbox").checked) selectedCategories.push("Catcher/Vanguard");
            }

            // ADC box logic
            if (document.getElementById("adc-checkbox").checked) selectedCategories.push("ADC");



            let numberForColormap = filterDataBySelectedCategories(scaledLocations, selectedCategories).length;

            // Quadrants to make sure data is scaled correctly no matter the data size
            quad0 = Math.ceil(.0015 * numberForColormap);
            quad1 = Math.ceil(.0030 * numberForColormap);
            quad2 = Math.ceil(.0040 * numberForColormap);
            quad3 = Math.ceil(.0050 * numberForColormap);
            quad4 = Math.ceil(.0062 * numberForColormap);
            quad5 = Math.ceil(.0090 * numberForColormap);
            quad6 = Math.ceil(.0270 * numberForColormap);

            console.log(quad0, quad1, quad2, quad3, quad4, quad5, quad6, numberForColormap)


            let colorScale = d3.scaleLinear()
            .domain([quad0, quad1, quad2, quad3, quad4, quad5, quad6]) // Domain 
            .range(["rgba(255, 255, 255, 0)", "rgba(255, 244, 0, 1)", "rgba(255, 210, 0, 1)", "rgba(255, 150, 0, 1)", "rgba(255, 130, 0, 1)", "rgba(255, 75, 0, 1)", "rgba(255, 0, 0, 1)"]); // RGBA with opacity

            // create new heatmap when different boxes are checked
            updateHeatmap(colorScale, scaledLocations, numRows, numCols, selectedCategories);
        }
    </script>
</body>
</html>




