<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Death Locations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../javascript/functions.js"></script> 
    <style>
        body {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1c1c1c;
            padding-left: 300px;
        }

        svg {
            border: 1px solid #ccc;
        }

        .death-marker {
            stroke: black;
            stroke-width: 1;
            font-size: 14px;
            font-weight: bold;
        }

        #controls {
        position: absolute;
        top: 90px;
        left: 90px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #000;
        }

        #adc-checkbox {
            margin-top: 35px; 
        }
    </style>
</head>   
<body>
    <!-- Checkboxes-->
    <div id="controls">
        <label><input type="checkbox" id="all-supports" checked> SUPPORT</label>
        <label><input type="checkbox" id="enchanter-warden-checkbox" name = category value = "Enchanter Warden" checked> Enchanter/Warden</label>
        <label><input type="checkbox" id="catcher-vanguard-checkbox" name = category value = "Catcher Vanguard" checked> Catcher/Vanguard</label>
        <label><input type="checkbox" id="adc-checkbox" checked> ADC</label>
        <label><input type="checkbox" id="attack-damage-carry" name = category value = "ADC" checked> attack-damage</label>
    </div>
    <!-- Side graph-->
    <div 
        id="champion-stats-table">
    </div>
    <style>
        #champion-stats-table {
        display: flex;
        justify-content: left;
        margin-top: 100px;
        }

        #champion-stats {
        width: 80%;
        border-collapse: collapse;
        text-align: center;
        }

        #champion-stats th, #champion-stats td {
        padding: 10px;
        text-align: center;
        border: 1px solid #ddd;
        }

        #champion-stats th {
        background-color: #f4f4f4;
        }

        #champion-stats td {
        background-color: #fafafa;
        }
    </style>
    <script>
        let svg; 
        let scaledLocations = []; 
        
        let quad0 = 0
        let quad1 = 1
        let quad2 = 2
        let quad3 = 3
        let quad4 = 4
        let quad5 = 5
        let quad6 = 6

        // Path to the .json file
        const PathToFile = "../Data_Gathering/match_data_FINAL.json"; 
    
        // Map Width and Height
        const MapHeight = 810;
        const MapWidth = 810;
        const GridSize = 30; // Grid size 
        const numCols = MapWidth / GridSize; // Number of columns in the grid
        const numRows = MapHeight / GridSize; // Number of rows in the grid
    
        // Color scale for the heatmap
        let colorScale = d3.scaleLinear()
            .domain([quad0, quad1, quad2, quad3, quad4, quad5, quad6]) // Domain 
            .range(["rgba(255, 255, 255, 0)", "rgba(255, 244, 0, 1)", "rgba(255, 210, 0, 1)", "rgba(255, 150, 0, 1)", "rgba(255, 130, 0, 1)", "rgba(255, 75, 0, 1)", "rgba(255, 0, 0, 1)"]); // RGBA with capacity
    
        // Load and process the data
        JsonToVariable(PathToFile).then(data => {
    
            // Extract death locations and the side from the data
            const deathLocationsWithSide = data.map(entry => {
                return entry.deathLocations.map(loc => ({
                    x: loc.x, // Attach x coordinate
                    y: loc.y, // Attach y coordinate
                    side: entry.side, // Attach side value 
                    championName: entry.championName // Attach champion name
                }));
            }).flat();
    





            // Scale the coordinates 
            const scaleCoordinates = (loc) => {
                const xScaled = (loc.x / 15000) * MapWidth;
                const yScaled = MapHeight - (loc.y / 15000) * MapHeight;
                const row = Math.floor(yScaled / GridSize);
                const col = Math.floor(xScaled / GridSize);
                return {
                    x: xScaled,
                    y: yScaled,
                    side: loc.side,
                    championName: loc.championName,
                    row: row,
                    col: col
                };
            };
    
            scaledLocations = deathLocationsWithSide.map(scaleCoordinates);
            console.log("Scaled Locations:", scaledLocations);
    
            const deathCounts = Array.from({ length: numRows }, () => Array(numCols).fill(0));
            // Number of deaths in each grid cell
            scaledLocations.forEach(loc => {
                const row = Math.floor(loc.y / GridSize);
                const col = Math.floor(loc.x / GridSize);
                deathCounts[row][col]++;
            });
    
            // Create SVG container 
            if (!svg) {
                svg = d3.select("body")
                    .append("svg")
                    .attr("width", MapWidth)
                    .attr("height", MapHeight);
    
                svg.append("image")
                    .attr("href", "Summoner's_Rift_Minimap.png")
                    .attr("width", MapWidth)
                    .attr("height", MapHeight);
            }
    
            // Plot the grid cells (heatmap)
            svg.selectAll(".grid-cell")
                .data(d3.range(numRows * numCols))
                .enter()
                .append("rect")
                .attr("class", "grid-cell")
                .attr("x", d => (d % numCols) * GridSize)
                .attr("y", d => Math.floor(d / numCols) * GridSize)
                .attr("width", GridSize)
                .attr("height", GridSize)
                .style("fill", d => {
                    const row = Math.floor(d / numCols);
                    const col = d % numCols;
                    const deathCount = deathCounts[row][col];
                    return colorScale(deathCount); // Set color based on the death count
                })
                .style("stroke", "none")
                .style("filter", "blur(14px)"); // Apply blur effect
    
            // Log unmapped champions
            const unmappedChampions = scaledLocations.filter(d => !ChampionRoles[d.championName]);
            console.log("Unmapped Champions:", unmappedChampions);
    

            ///////////////// LOGIC FOR CHECKBOXES ON THE LEFT HAND SIDE ///////////////////////////
            // Attach event listeners to checkboxes (SUPPORTS)
            document.getElementById("all-supports").addEventListener("change", (event) => {
                const isChecked = event.target.checked;

                // Set all support boxes to be active
                document.getElementById("enchanter-warden-checkbox").checked = isChecked;
                document.getElementById("catcher-vanguard-checkbox").checked = isChecked;

                // Update the heatmap 
                updateHeatmapBasedOnCheckboxes();
            });

            // Function to update the state of "all-supports" based on the other checkboxes
            //checks if all support boxes are checked, and if not, will uncheck the SUPPORT box
            const updateAllSupportsState = () => {
                const enchanterChecked = document.getElementById("enchanter-warden-checkbox").checked;
                const catcherChecked = document.getElementById("catcher-vanguard-checkbox").checked;

                // "all-supports" is checked only if all support boxes are checked
                document.getElementById("all-supports").checked = enchanterChecked && catcherChecked;

                // Update the heatmap
                updateHeatmapBasedOnCheckboxes();
            };

            // Attach event listeners to all support boxes
            document.getElementById("enchanter-warden-checkbox").addEventListener("change", updateAllSupportsState);
            document.getElementById("catcher-vanguard-checkbox").addEventListener("change", updateAllSupportsState);







            // Attach event listeners to checkboxes (ADC's)
            document.getElementById("adc-checkbox").addEventListener("change", (event) => {
                const isChecked = event.target.checked;

                // Set all ADC boxes to be active
                document.getElementById("attack-damage-carry").checked = isChecked;

                // Update the heatmap 
                updateHeatmapBasedOnCheckboxes();

            // Function to update the state of "all-adc" based on the other checkboxes
            //checks if all adc boxes are checked, and if not, will uncheck the ADC box
            const updateAllADCState = () => {
                const attackDamageChecked = document.getElementById("attack-damage-carry").checked;

                // "all-ADC" is checked only if all adc boxes are checked
                document.getElementById("adc-checkbox").checked = attackDamageChecked;

                // Update the heatmap
                updateHeatmapBasedOnCheckboxes();
            };

            document.getElementById("attack-damage-carry").addEventListener("change", updateAllADCState);



            });
            document.getElementById("attack-damage-carry").addEventListener("change", updateHeatmapBasedOnCheckboxes);
            ////------------------------------------------------------------------------------/////






            // Initial render of the heatmap with all categories
            updateHeatmapBasedOnCheckboxes(); 
        }).catch(error => console.error("Error loading or processing data:", error));
    

        function updateHeatmapBasedOnCheckboxes() {
            // Get selected categories based on current checkboxes
            const selectedCategories = [];

            // If SUPPORT box is checked, check all support boxes
            if (document.getElementById("all-supports").checked) 
            {
                selectedCategories.push("Enchanter/Warden", "Catcher/Vanguard");
            } 
            // Else continue normally
            else 
            {
                if (document.getElementById("enchanter-warden-checkbox").checked) selectedCategories.push("Enchanter/Warden");
                if (document.getElementById("catcher-vanguard-checkbox").checked) selectedCategories.push("Catcher/Vanguard");
            }

            // ADC box logic
            if (document.getElementById("adc-checkbox").checked) selectedCategories.push("ADC");



            let numberForColormap = filterDataBySelectedCategories(scaledLocations, selectedCategories).length;

            // Quadrants to make sure data is scaled correctly no matter the data size
            quad0 = Math.ceil(.0015 * numberForColormap);
            quad1 = Math.ceil(.0030 * numberForColormap);
            quad2 = Math.ceil(.0040 * numberForColormap);
            quad3 = Math.ceil(.0050 * numberForColormap);
            quad4 = Math.ceil(.0062 * numberForColormap);
            quad5 = Math.ceil(.0090 * numberForColormap);
            quad6 = Math.ceil(.0270 * numberForColormap);

            console.log(quad0, quad1, quad2, quad3, quad4, quad5, quad6, numberForColormap)


            let colorScale = d3.scaleLinear()
            .domain([quad0, quad1, quad2, quad3, quad4, quad5, quad6]) // Domain 
            .range(["rgba(255, 255, 255, 0)", "rgba(255, 244, 0, 1)", "rgba(255, 210, 0, 1)", "rgba(255, 150, 0, 1)", "rgba(255, 130, 0, 1)", "rgba(255, 75, 0, 1)", "rgba(255, 0, 0, 1)"]); // RGBA with opacity

            // create new heatmap when different boxes are checked
            updateHeatmap(colorScale, scaledLocations, numRows, numCols, selectedCategories);
            printAllGoodData();
        }



        async function GetProperData(path) 
            {
                const data = await JsonToVariable(path); 

                const categoryDetails = extractCategoryDetails(data); 
                //console.log("category details:", categoryDetails);

                return categoryDetails;
            }

        async function loadThreeMostPlayed() {
            // Get the selected categories from the checkboxes
            const Categories = Array.from(document.querySelectorAll('input[name="category"]:checked'))
                .map(checkbox => checkbox.value) 
                .flatMap(value => value.split(' '));

            const Details = await GetProperData(PathToFile); 

            console.log("current categories: ", Categories)

            const topChampions = getTopChampions(Categories, Details); 
            return topChampions;
            }

        async function printAllGoodData(){
            const MyTopThree = await loadThreeMostPlayed();
            console.log("3 most played: ", MyTopThree);

            const categoryDetails = await GetProperData(PathToFile);

            MyTopThree.forEach((name) => {  
                getSpecificChampionData(name, categoryDetails);   
            });   
              
        }
        
        printAllGoodData()




        async function createChampionStatsTable(selectedChampions) {
            const MyTopThree = await loadThreeMostPlayed();
            const categoryDetails = await GetProperData(PathToFile);

            // Fetch specific data for each champion
            const FinalData = await Promise.all(
                MyTopThree.map(name => getSpecificChampionData(name, categoryDetails))
            );

            console.log("FinalData: ", FinalData)

            const tableContainer = document.getElementById('champion-stats-table');
            tableContainer.innerHTML = ''; // Clear previous table if any

            if (selectedChampions.length === 0) {
                tableContainer.innerHTML = '<p>No champions selected</p>';
                return;
            }

            // Create a new table element
            const table = document.createElement('table');
            table.id = 'champion-stats';

            // Create the header row
            const headerRow = document.createElement('tr');
            const headerStatsCell = document.createElement('th');
            headerStatsCell.textContent = 'Stats';
            headerRow.appendChild(headerStatsCell);


            FinalData.forEach(championData => {
                const th = document.createElement('th');
                th.textContent = championData.championName;
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            // Define stats and corresponding keys
            const stats = [
                {label: 'Total number of games', dataKey: 'numberOfGames' },
                {label: 'My Deaths Compared to Team', dataKey: 'avgDeathsPerGame' },
                {label: 'My Kill Participation', dataKey: 'avgKillParticipation' },
                {label: 'My Win Rate', dataKey: 'winRate' },
                {label: 'My KDA', dataKey: 'avgKDA' }
            ];

            // Populate table rows for each stat
            for (const stat of stats) {
                const row = document.createElement('tr');
                const statCell = document.createElement('td');
                statCell.textContent = stat.label;
                row.appendChild(statCell);

                console.log("selected Champions: ", selectedChampions)
                console.log("My top Three: ", MyTopThree)

                let i = 0;
                for (const champion of MyTopThree) {
                    const dataCell = document.createElement('td');
                    
                    console.log("champion: (inside of for loop) ", MyTopThree[i].champion)
                    // Find the specific data for this champion and stat
                    const championData = FinalData.find(data => data.championName === MyTopThree[i].champion);
                    if (championData) {
                        const value = championData[stat.dataKey];
                        dataCell.textContent = value !== undefined ? value : 'N/A';
                    } else {
                        dataCell.textContent = 'N/A'; // Fallback if no data is found
                    }

                    row.appendChild(dataCell);
                    i += 1;
                }
                table.appendChild(row);
                
            }

            // Append the completed table to the container
            tableContainer.appendChild(table);
        }

        // Event listener to watch for checkbox changes
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async () => {
                // Get the selected champions from the checkboxes
                const selectedChampions = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(checkbox => checkbox.id.replace('-checkbox', '')); 

                // Create the table with selected champions
                await createChampionStatsTable(selectedChampions);
            });
        });

        // Initial table creation when the page loads 
        document.addEventListener('DOMContentLoaded', async () => {
            const selectedChampions = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
                .map(checkbox => checkbox.id.replace('-checkbox', '')); 
            await createChampionStatsTable(selectedChampions); 
        });


    </script>
</body>
</html>




